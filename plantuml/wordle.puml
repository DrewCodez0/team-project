@startuml Wordle
'https://plantuml.com/class-diagram
skinparam groupInheritance 2
skinparam Linetype ortho

enum Status {
    INITIAL
    IN_PROGRESS
    WRONG
    PARTIAL
    CORRECT
}

abstract class AbstractLetter {
    + {abstract} getCharacter(): char
    + {abstract} setCharacter(c: char): void
    + {abstract} resetCharacter(): void
    + {abstract} getStatus(): Status
    + {abstract} setStatus(status: Status): void
    + {abstract} isNull(): boolean
    + toString(): String
    + equals(obj: Object): boolean
    + hashCode(): int
}
AbstractLetter --> Status

class Letter extends AbstractLetter {
    - status: Status
    - character: char
    + Letter(character: char)
    + Letter()
    + getCharacter(): char
    + setCharacter(character: char): void
    + resetCharacter(): void
    + getStatus(): Status
    + setStatus(status: Status): void
    + isNull(): boolean
}
Letter --> Status

abstract class AbstractWord {
    + {abstract} getLetter(index: int): AbstractLetter
    + {abstract} length(): int
    + {abstract} isEmpty(): boolean
    + {abstract} isFull(): boolean
    + {abstract} isCorrect(): boolean
    + {abstract} toString(): String
    + equals(obj: Object): boolean
    + hashCode(): int
}
AbstractWord --> AbstractLetter

class Word extends AbstractWord {
    - letters: AbstractLetter[]
    + Word(word: String)
    + Word(length: int)
    + getLetter(index: int): AbstractLetter
    + length(): int
    + isEmpty(): boolean
    + isFull(): boolean
    + isCorrect(): boolean
    + toString(): String
}
Word --> AbstractLetter

class WordFactory {
    - {static} DEFAULT_WORD: String
    - WordFactory()
    + {static} createWord(word: String): AbstractWord
    + {static} createEmptyWord(word: String): AbstractWord
    + {static} createDefaultWord(word: String): AbstractWord
    + {static} createWordToGuess(word: String): AbstractWord
    + {static} updateWord(word: AbstractWord, statuses: Status[]): void
    - {static} generateCorrectArray(length: int): Status[]
    + {static} checkGuess(guess: AbstractWord, expected: AbstractWord): Status[]
    + {static} submitGuess(guess: AbstractWord, expected: AbstractWord): void
}
WordFactory --> AbstractWord
WordFactory --> Status
WordFactory --> Word

exception WordNotFoundException {
    + WordNotFoundException(message: String)
}

class ViewHelper {
    + {static} LETTER: String
    + {static} TITLE: String
    + {static} BUTTON: String
    + {static} SQUARE_SIZE: int
    + {static} MARGINS: int
    + {static} SQUARE_SCALE: double
    - ViewHelper()
    + {static} setTheme(component: JComponent, theme: Theme, type: String): void
    + {static} setTheme(component: JComponent, theme: Theme): void
    + {static} createBufferPanel(width: int, height: int, theme: Theme): JPanel
    + {static} drawGameState(gameState: GameState, g2d: Graphics2D, theme: Theme, panelSize: Dimension, shakeOffset: float): void
    - {static} getSquareSize(gameState: GameState, panelSize: Dimension): int[]
    - {static} drawLetter(g: Graphics2D, letter: AbstractLetter, x: int, y: int, size: int, theme: Theme): void
    - {static} getTransform(x: float, y: int, size: int): AffineTransform
    - {static} drawBoxBackground(g: Graphics2D, letter: AbstractLetter, transform: AffineTransform, theme: Theme): void
    - {static} drawBoxOutline(g: Graphics2D, transform: AffineTransform, theme: Theme): void
    - {static} drawBoxLetter(g: Graphics2D, letter: AbstractLetter, x: int, y: int, size: int, theme: Theme): void
}
ViewHelper --> Theme
ViewHelper --> GameState
ViewHelper --> AbstractLetter
ViewHelper --> AbstractWord

class ViewModel<T> {
    - state: T
    - viewName: String
    + ViewModel(state: T)
    + getState(): T
    + getViewName(): String
}

class ViewManagerModel extends ViewModel {
    + ViewManagerModel()
}

class ViewManager {
    - cardLayout: CardLayout
    - views: JPanel
    - viewManagerModel: ViewManagerModel
    + ViewManager(views: JPanel, cardLayout: CardLayout, viewManagerModel: ViewManagerModel)
    + propertyChange(evt: PropertyChangeEvent): void
}
ViewManager --> ViewManagerModel

class OptionsViewModel extends ViewModel {
    + OptionsViewModel()
}
OptionsViewModel --> OptionsState

class OptionsController {
    + OptionsController(OptionsInputBoundary)
    + execute(): void
}
OptionsController --> OptionsState
OptionsController --> OptionsInputBoundary

class OptionsPresenter extends OptionsOutputBoundary {
    + OptionsPresenter(ViewManagerModel, OptionsViewModel, StartViewModel)
    + prepareStartView(): void
}
OptionsPresenter --> OptionsViewModel
OptionsPresenter --> StartViewModel

interface OptionsOutputBoundary {
    + prepareStartView(): void
}

class OptionsState {
    - length: int
    - maxGuesses: int
    + OptionsState()
    + getTheme(): Theme
    + setTheme(theme: Theme): void
    + getLength(): int
    + setLength(length: int): void
    + getMaxGuesses(): int
    + setMaxGuesses(maxGuesses: int): void
    + getLanguage(): Language
    + setLanguage(language: Language): void
}
OptionsState --> Theme
OptionsState --> Language

interface OptionsInputBoundary {
    + {abstract} execute(inputData: OptionsState): void
}

class OptionsInteractor implements OptionsInputBoundary {
    + OptionsInteractor(OptionsDataAccessInterface, OptionsOutputBoundary)
    + execute(inputData: OptionsState): void
}
OptionsInteractor --> OptionsState
OptionsInteractor --> OptionsOutputBoundary
OptionsInteractor --> OptionsDataAccessInterface

interface OptionsDataAccessInterface {
    + getOptions(): OptionsState
    + saveOptions(options: OptionsState): void
}
OptionsDataAccessInterface ..* OptionsState

class OptionsView {
    - optionsController: OptionsController
    - viewName: String
    + OptionsView(OptionsViewModel)
}
OptionsView --> OptionsViewModel
OptionsView --> OptionsController


class EndView {
    - {static} VIEW_NAME: String
    - endViewModel: EndViewModel
    - endController: EndController
    + EndView(endViewModel: EndViewModel, startViewModel: StartViewModel)
    + actionPerformed(e: ActionEvent): void
    + propertyChange(evt: PropertyChangeEvent): void
    - updateView(endState: EndState): void
    + getViewName(): String
    + setEndController(endController: EndController): void
}
EndView --> Theme
EndView --> EndViewModel
EndView --> EndState
EndView --> StartViewModel
EndView --> EndController
EndView --> ViewHelper

class EndViewModel extends ViewModel {
    + EndViewModel()
}
EndViewModel --> EndState

class EndState {
     - word: String
     - won: boolean
     - guessesUsed: int
     - maxGuesses: int
     - message: String
     + EndState()
     + getWord(): String
     + setWord(word: String): void
     + isWon(): boolean
     + setWon(won: boolean): void
     + getGuessesUsed(): int
     + setGuessesUsed(guessesUsed: int): void
     + getMaxGuesses(): int
     + setMaxGuesses(maxGuesses: int): void
     + getMessage(): String
     + setMessage(message: String): void
}

class EndPresenter implements EndOutputBoundary {
    + EndPresenter(ViewManagerModel, EndViewModel, GameViewModel, StartViewModel)
    + prepareSuccessView(endOutputData: EndOutputData): void
    + prepareFailView(outputData: EndOutputData): void
    + prepareGameView(): void
    + prepareStartView(): void
}
EndPresenter --> ViewManagerModel
EndPresenter --> EndViewModel
EndPresenter --> GameViewModel
EndPresenter --> StartViewModel
EndPresenter --> EndOutputData
EndPresenter --> EndState

class EndGameRecord {
    - word: String
    - won: boolean
    - guessesUsed: int
    + EndGameRecord(word: String, won: boolean, guessesUsed: int)
    + getWord(): String
    + isWon(): boolean
    + getGuessesUsed(): int
    + toString(): String
    + equals(obj: Object): boolean
    + hashCode(): int
}

class EndOutputData {
    - word: String
    - won: boolean
    - guessesUsed: int
    - maxGuesses: int
    - message: String
    + EndOutputData(word: String, won: boolean, guessesUsed: int, maxGuesses: int)
    - generateWinMessage(guesses: int): String
    + getWord(): String
    + isWon(): boolean
    + getGuessesUsed(): int
    + getMaxGuesses(): int
    + getMessage(): String
}

interface EndOutputBoundary {
    + {abstract} prepareSuccessView(endOutputData: EndOutputData): void
    + {abstract} prepareFailView(outputData: EndOutputData): void
    + {abstract} prepareGameView(): void
    + {abstract} prepareStartView(): void
}
EndOutputBoundary --> EndOutputData

class EndController {
    + EndController(EndInputBoundary)
    + execute(word: String, won: boolean, guessesUsed: int, maxGuesses: int): void
    + switchToStartView(): void
    + replay(word: String, won: boolean, guessesUsed: int, maxGuesses: int): void
}
EndController --> EndInputBoundary
EndController --> EndInputData

class EndInputData {
    - word: String
    - won: boolean
    - guessesUsed: int
    - maxGuesses: int
    + EndInputData(word: String, won: boolean, guessesUsed: int, maxGuesses: int)
    + getWord(): String
    + isWon(): boolean
    + getGuessesUsed(): int
    + getMaxGuesses(): int
}

interface EndInputBoundary {
    + {abstract} execute(endInputData: EndInputData): void
    + {abstract} prepareStartView(): void
    + {abstract} prepareNewGame(endInputData: EndInputData): void
}
EndInputBoundary --> EndInputData


class EndInteractor implements EndInputBoundary {
    - endDataAccess: EndDataAccessInterface
    - endPresenter: EndOutputBoundary
    + EndInteractor(endDataAccess: EndDataAccessInterface, endOutputBoundary: EndOutputBoundary)
    + execute(endInputData: endInputData): void
    + prepareStartView(): void
    + prepareNewGame(endInputData: EndInputData): void
}
EndInteractor --> EndOutputBoundary
EndInteractor --> EndDataAccessInterface
EndInteractor --> EndInputData

interface EndDataAccessInterface {
    + {abstract} saveGameRecord(record: EndGameRecord): void
    + {abstract} getGameRecords(): EndGameRecord[]
}
EndDataAccessInterface --> EndGameRecord

class GameViewModel extends ViewModel {
    + {static} STATE: String
    + {static} SHAKE: String
    + {static} NEW_GAME: String
    + GameViewModel()
}
GameViewModel --> GameState

class GameView {
    - {static} VIEW_NAME: String
    - shakeOffset: float
    - gameViewModel: GameViewModel
    - optionsViewModel: OptionsViewModel
    - gameController: GameController
'    - gamePanel: JPanel
'    - menu: JButton
'    - submit: JButton
    + GameView(GameViewModel, OptionsViewModel)
    + actionPerformed(e: ActionEvent): void
    + propertyChange(evt: PropertyChangeEvent): void
    + paint(g: Graphics): void
    + getViewName(): String
    + setGameController(gameController: GameController): void
    - initializeButtons(buttonList: ArrayList<JButton>): JPanel
    - initializeLayout(title: JLabel, gamePanel: JPanel, buttons: JPanel): void
    - initializeInputHandlers(): void
    - getTheme(): Theme
}
GameView --> GameViewModel
GameView --> OptionsViewModel
GameView --> GameController
GameView --> GameState
GameView --* KeyAction
GameView --* WordShake
GameView --> ViewHelper

-class KeyAction {
    - view: GameView
    - type: String
    + KeyAction(view: GameView, type: String)
    + actionPerformed(e: ActionEvent): void
}
KeyAction --> GameView

-class WordShake {
    - view: GameView
    + WordShake(view: GameView)
    + run(): void
    - shake(time: double): float
}
WordShake --> GameView

class GameController {
    + {static} ENTER: String
    + {static} LETTER: String
    + {static} BACKSPACE: String
    - gameInteractor: GameInputBoundary
    + GameController(GameInputBoundary)
    + startNewGame(): void
    + execute(gameInputData: GameState, e: ActionEvent): void
    + executeSubmit(gameInputData: GameState): void
    + switchToStartView(): void
    + switchToEndView(gameState: GameState): void
}
GameController --> GameInputBoundary
GameController --> GameState

' class GameInputData {
'     - length: int
'     - maxGuesses: int
'     + GameInputData(length: int, maxGuesses: int)
'     + getLength(): int
'     + getMaxGuesses(): int
' }

interface GameInputBoundary {
    + {abstract} executeLetter(gameInputData: GameState, letter: char): void
    + {abstract} executeSubmit(gameInputData: GameState): void
    + {abstract} executeBackspace(gameInputData: GameState): void
    + {abstract} prepareNewGame(): void
    + {abstract} prepareStartView(): void
    + {abstract} prepareEndView(gameState: GameState)
}
GameInputBoundary --> GameState

    ' + {abstract} start(): void
    ' + {abstract} getStatus(): GameState
    ' + {abstract} update(input: char): GameState

interface GameOutputBoundary {
    + {abstract} updateGameView(state: GameState): void
    + {abstract} shakeWord(state: GameState): void
    + {abstract} prepareStartView(): void
    + {abstract} prepareEndView(state: GameState): void
}
GameOutputBoundary --> GameState

class GamePresenter implements GameOutputBoundary {
    - viewManagerModel: ViewManagerModel
    - gameViewModel: GameViewModel
    - startViewModel: StartViewModel
    - endViewModel: EndViewModel
    + GamePresenter(ViewManagerModel, GameViewModel, StartViewModel, EndViewModel)
    + updateGameView(gameState GameState): void
    + shakeWord(gameState: GameState): void
    + prepareStartView(): void
    + prepareEndView(gameState: GameState): void
}
GamePresenter --> ViewManagerModel
GamePresenter --> GameViewModel
GamePresenter --> StartViewModel
GamePresenter --> EndViewModel
GamePresenter --> GameState

class GameInteractor implements GameInputBoundary {
    - gameDataAccess: GameDataAccessInterface
    - gamePresenter: GameOutputBoundary
    - endInteractor: EndInputBoundary
    - optionsViewModel: OptionsViewModel
    + GameInteractor(GameDataAccessInterface, GameOutputBoundary, EndInputBoundary, OptionsViewModel)
    + executeLetter(gameInputData: GameState, letter: char): void
    + executeSubmit(gameInputData: GameState): void
    + executeBackspace(gameInputData: GameState): void
    + prepareNewGame(): void
    + prepareStartView(): void
    + prepareEndView(gameState: GameState): void
}
GameInteractor --> GameOutputBoundary
GameInteractor --> GameState
GameInteractor --> GameDataAccessInterface
GameInteractor --> WordNotFoundException
GameInteractor --> WordFactory
GameInteractor --> EndInputData
GameInteractor --> EndInputBoundary
GameInteractor --> OptionsViewModel

    ' - wordChecker: WordChecker
    ' - status: GameStatus
    ' + GameInteractor(config: Map<String, Object>)
    ' + start(): void
    ' + getStatus(): GameStatus
    ' + update(input: char): GameStatus
    ' - generateWord(length: int): String

' class GameOutputData {
'     - currentGuess: int
'     - words: AbstractWord[]
'     - wordToGuess: AbstractWord
'     + GameOutputData()
'     + toString(): String
' }

interface GameDataAccessInterface {
    + getRandomWord(length: int, language: Language): String
    + isValidWord(word: String, language: Language): boolean
}
GameDataAccessInterface --> Language
GameDataAccessInterface --> WordNotFoundException

class GameState {
    - {static} COLORS: Map<Status, String>
    - length: int
    - maxGuesses: int
    - language: Language
    - currentGuess: int
    - words: AbstractWord[]
    - wordToGuess: AbstractWord
    + GameState()
    + GameState(wordToGuess: AbstractWord, maxGuesses: int, language: Language)
    + GameState(wordToGuess: AbstractWord, maxGuesses: int)
    + GameState(wordToGuess: AbstractWord, words: AbstractWord[], language: Language)
    + GameState(wordToGuess: AbstractWord, words: AbstractWord[])
    - initializeEmptyWords(): void
    - initializeCurrentGuess(): void
    - initializeCurrentLetter(): void
    + toString(): String
    + getLength(): int
    + getMaxGuesses(): int
    + getLanguage(): Language
    + getCurrentGuess(): int
    + getCurrentLetter(): AbstractLetter
    + getCurrentLetterIndex(): int
    + getWords(): AbstractWord[]
    + getWordToGuess(): AbstractWord
    + nextLetter(character: char): void
    + previousLetter(): void
    + nextWord(): void
    + submit(): void
    + finished(): boolean
}
GameState --> AbstractWord
GameState --> Language
GameState --> AbstractLetter
GameState --> Status
GameState --> WordFactory

class StatsController {
    + StatsController(statsInputBoundary: StatsInputBoundary, statsOutputBoundary: StatsOutputBoundary)
    + execute(): void
    + switchToStartView(): void
}
StatsController --> StatsInputBoundary
StatsController --> StatsInputData
StatsController --> StatsOutputBoundary

class StatsOutputData {
    - statsState: StatsState
    - hasStats: boolean
    + StatsOutputData(statsState: StatsState, hasStats: boolean)
    + getStatsState(): StatsState
    + hasStats(): boolean
}
StatsOutputData --> StatsState

class StatsPresenter implements StatsOutputBoundary {
    + StatsPresenter(ViewManagerModel, StatsViewModel, StartViewModel)
    + prepareSuccessView(): void
    + prepareFailView(): void
    + prepareDefaultView(): void
    + prepareStartView(): void
}
StatsPresenter --> StatsViewModel
StatsPresenter --> StartViewModel
StatsPresenter --> StatsOutputData

class StatsViewModel extends ViewModel {
    + StatsViewModel()
}
StatsViewModel --> StatsState

class StatsView {
    - {static} VIEW_NAME: String
    - statsViewModel: StatsViewModel
    - statsController: StatsController
    + StatsView(StatsViewModel)
    - setupUI(): void
    + actionPerformed(e: ActionEvent): void
    + propertyChange(evt: PropertyChangeEvent): void
    - updateStatsDisplay(state: StatsState): void
    + getViewName(): String
    + setStatsController(statsController: StatsController): void
}
StatsView --> StatsViewModel
StatsView --> StatsController
StatsView --> StatsState
StatsView --> Theme
StatsView --> ViewHelper

class StatsInputData

interface StatsInputBoundary {
    + {abstract} execute(inputData: StatsInputData): void
}

class StatsInteractor implements StatsInputBoundary {
    + StatsInteractor(StatsDataAccessInterface, StatsOutputBoundary)
    + execute(inputData: StatsInputData): void
}
StatsInteractor --> StatsInputData
StatsInteractor --> StatsOutputBoundary
StatsInteractor --> StatsDataAccessInterface

interface StatsOutputBoundary {
    + prepareSuccessView(): void
    + prepareFailView(): void
    + prepareDefaultView(): void
    + prepareStartView(): void
}

class StatsState {
    - totalGames: int
    - gamesWon: int
    - currentWinStreak: int
    - longestWinStreak: int
    - theme: Theme
    + StatsState()
    + getTotalGames(): int
    + setTotalGames(totalGames: int): void
    + getGamesWon(): int
    + setGamesWon(gamesWon: int): void
    + getCurrentWinStreak(): int
    + setCurrentWinStreak(currentWinStreak: int): void
    + getLongestWinStreak(): int
    + setLongestWinStreak(longestWinStreak: int): void
    + getTheme(): Theme
    + setTheme(theme: Theme): void
}
StatsState --> Theme

interface StatsDataAccessInterface {
    + getStats(): StatsState
    + saveStats(stats: StatsState): void
}
StatsDataAccessInterface --> StatsState

class StartViewModel extends ViewModel {
    + StartViewModel()
}
StartViewModel --> Theme

class StartView {
    - {static} VIEW_NAME: String
    - startController: StartController
'    - play: JButton
'    - options: JButton
'    - stats: JButton
'    - exit: JButton
    + StartView(StartViewModel)
    + actionPerformed(e: ActionEvent): void
    + propertyChange(evt: PropertyChangeEvent): void
    + getViewName(): String
    + setStartController(): void
}
StartView --> Theme
StartView --> StartViewModel
StartView --> StartController
StartView --> ViewHelper

class StartController {
    - startInteractor: StartInputBoundary
    + StartController(startInputBoundary: StartInputBoundary)
    + prepareStartView(): void
    + switchToGameView(): void
    + switchToOptionsView(): void
    + switchToStatsView(): void
}
StartController --> StartInputBoundary

interface StartInputBoundary {
    + {abstract} prepareStartView(): void
    + {abstract} prepareGameView(): void
    + {abstract} prepareOptionsView(): void
    + {abstract} prepareStatsView(): void
}

class StartInteractor implements StartInputBoundary {
    - startDataAccess: StartDataAccessInterface
    - startPresenter: StartOutputBoundary
    + StartInteractor(StartDataAccessInterface, StartOutputBoundary)
    + prepareStartView(): void
    + prepareGameView(): void
    + prepareOptionsView(): void
    + prepareStatsView(): void
}
StartInteractor --> Theme
StartInteractor --> StartOutputBoundary
StartInteractor --> StartDataAccessInterface

interface StartOutputBoundary {
    + {abstract} prepareStartView(theme: Theme): void
    + {abstract} prepareGameView(): void
    + {abstract} prepareOptionsView(): void
    + {abstract} prepareStatsView(): void
}
StartOutputBoundary --> Theme

interface StartDataAccessInterface {
    + getDefaultTheme(): Theme
}
StartDataAccessInterface --> Theme

class StartPresenter implements StartOutputBoundary {
    - viewManagerModel: ViewManagerModel
    - startViewModel: StartViewModel
    - gameViewModel: GameViewModel
    - optionsViewModel: OptionsViewModel
    - statsViewModel: StatsViewModel
    + StartPresenter(ViewManagerModel, StartViewModel, GameViewModel, OptionsViewModel, StatsViewModel)
    + prepareStartView(theme: Theme): void
    + prepareGameView(): void
    + prepareOptionsView(): void
    + prepareStatsView(): void
}
StartPresenter --> Theme
StartPresenter --> ViewManagerModel
StartPresenter --> StartViewModel
StartPresenter --> GameViewModel
StartPresenter --> OptionsViewModel
StartPresenter --> StatsViewModel

class FileDataAccessObject implements OptionsDataAccessInterface, StatsDataAccessInterface, StartDataAccessInterface, EndDataAccessInterface {
    + getOptions(): OptionsState
    + saveOptions(options: OptionsState): void
    + getStats(): StatsState
    + saveStats(stats: StatsState): void
    + getDefaultTheme(): Theme
    + getGameRecords(): EndGameRecord[]
    + saveGameRecord(record: EndGameRecord): void
}
FileDataAccessObject --> OptionsState
FileDataAccessObject --> StatsState
FileDataAccessObject --> Theme
FileDataAccessObject --> EndGameRecord

class WordDataAccessObject implements GameDataAccessInterface {
    - wordGenerator: WordGenerator
    - wordChecker: WordChecker
    - {static} MAX_TRIES: int
    + WordDataAccessObject(wordGenerator: WordGenerator, wordChecker: WordChecker)
    + getRandomWord(length: int, language: Language): String
    + isValidWord(word: String, language Language): boolean
}
WordDataAccessObject --> WordGenerator
WordDataAccessObject --> WordChecker
WordDataAccessObject --> Language
WordDataAccessObject --> WordNotFoundException

interface WordGenerator {
    + {abstract} getRandomWord(length: int): String
    + {abstract} getDefinitions(word: String, language: Language): JSONArray
}
WordGenerator --> Language

interface WordChecker {
    + {abstract} isValidWord(word: String, language: Language): boolean
    + {abstract} getDefinitions(word: String, language: Language): JSONArray
}
WordChecker --> Language

abstract class AbstractAPI {
    # {static} CONTENT_TYPE_LABEL: String
    # {static} CONTENT_TYPE_JSON: String
    # {static} FAIL_STRING: String
    # baseURL: String
    + AbstractAPI(baseUrl: String)
    + fetch(params: String): JSONArray
}
AbstractAPI --> WordNotFoundException

class APIWordGenerator extends AbstractAPI implements WordGenerator {
    - {static} LANGUAGES: Map<Language, String>
    + APIWordGenerator()
    + getRandomWord(length: int, language: Language): String
}
APIWordGenerator --> Language
APIWordGenerator --> WordNotFoundException

class DebugWordGenerator implements WordGenerator {
    + getRandomWord(length: int, language: Language): String
}
DebugWordGenerator --> Language

class APIWordChecker extends AbstractAPI implements WordChecker {
    - wordData: JSONObject
    - validCache: Map<String, Boolean>
    - {static} LANGUAGES: Map<Language, String>
    - {static} JSON_WORD: String
    + APIWordChecker()
    + isValidWord(word: String, language: Language): boolean
    + getDefinitions(word: String, language: Language): JSONArray
}
APIWordChecker --> Language
APIWordChecker --> WordNotFoundException

enum Language {
    ENGLISH
    FRENCH
    SPANISH
    ITALIAN
    GERMAN
    PORTUGUESE
}

class AppBuilder {
    - cardPanel: JPanel
    - cardLayout: CardLayout
    - viewManagerModel: ViewManagerModel
    - viewManager: ViewManager
    - startView: StartView
    - startViewModel: StartViewModel
    - gameView: GameView
    - gameViewModel: GameViewModel
    - optionsView: OptionsView
    - optionsViewModel: OptionsViewModel
    - endView: EndView
    - endViewModel: EndViewModel
    - statsView: StatsView
    - statsViewModel: StatsViewModel
    - fileDataAccessObject: FileDataAccessObject
    - wordDataAccessObject: WordDataAccessObject
    + AppBuilder()
    + addStartView(): AppBuilder
    + addEndView(): AppBuilder
    + addGameView(): AppBuilder
    + addOptionsView(): AppBuilder
    + addStatsView(): AppBuilder
    + addStartUseCase(): AppBuilder
    + addEndUseCase(): AppBuilder
    + addGameUseCase(): AppBuilder
    + addOptionsUseCase(): AppBuilder
    + addStatsUseCase(): AppBuilder
    + build(): JFrame
}
' AppBuilder --> ViewManagerModel
' AppBuilder --> ViewManager
' AppBuilder --> OptionsView
' AppBuilder --> OptionsViewModel
' AppBuilder --> GameView
' AppBuilder --> GameViewModel
' AppBuilder --> EndView
' AppBuilder --> EndViewModel
' AppBuilder --> StartView
' AppBuilder --> StartViewModel
' AppBuilder --> StatsView
' AppBuilder --> StatsViewModel

' AppBuilder --> OptionsOutputBoundary
' AppBuilder --> OptionsPresenter
' AppBulider --> OptionsInputBoundary
' AppBuilder --> OptionsInteractor
' AppBuilder --> OptionsController

' AppBuilder --> GameOutputBoundary
' AppBuilder --> GamePresenter
' AppBuilder --> GameInputBoundary
' AppBuilder --> GameInteractor
' AppBuilder --> GameController

' AppBuilder --> EndOutputBoundary
' AppBuilder --> EndPresenter
' AppBuilder --> EndInputBoundary
' AppBuilder --> EndInteractor
' AppBuilder --> EndController

' AppBuilder --> StartOutputBoundary
' AppBuilder --> StartPresenter
' AppBuilder --> StartInputBoundary
' AppBuilder --> StartInteractor
' AppBuilder --> StartController

' AppBuilder --> StatsOutputBoundary
' AppBuilder --> StatsPresenter
' AppBuilder --> StatsInputBoundary
' AppBuilder --> StatsInteractor
' AppBuilder --> StatsController

interface Theme {
    + {abstract} getBackgroundColor(): Color
    + {abstract} getTextColor(): Color
    + {abstract} getOutlineColor(): Color
    + {abstract} getLetterFont(): Font
    + {abstract} getTitleFont(): Font
    + {abstract} getButtonFont(): Font
    + {abstract} getColorForStatus(status: Status): Color
    + {abstract} getLetterBox(): Shape
}
Theme --> Status

' Can potentially add an AnimatedTheme interface later
' Also support for user-defined themes

class LightTheme implements Theme {
    - backgroundColor: Color
    - textColor: Color
    - outlineColor: Color
    - letterFont: Font
    - titleFont: Font
    - buttonFont: Font
    - statusColors: Map<Status, Color>
    - letterBox: Shape
    + LightTheme()
    + getBackgroundColor(): Color
    + getTextColor(): Color
    + getOutlineColor(): Color
    + getLetterFont(): Font
    + getTitleFont(): Font
    + getButtonFont(): Font
    + getColorForStatus(status: Status): Color
    + getLetterBox(): Shape
}
LightTheme --> Status

class DarkTheme implements Theme {
    - backgroundColor: Color
    - textColor: Color
    - outlineColor: Color
    - letterFont: Font
    - titleFont: Font
    - buttonFont: Font
    - statusColors: Map<Status, Color>
    - letterBox: Shape
    + DarkTheme()
    + getBackgroundColor(): Color
    + getTextColor(): Color
    + getOutlineColor(): Color
    + getLetterFont(): Font
    + getTitleFont(): Font
    + getButtonFont(): Font
    + getColorForStatus(status: Status): Color
    + getLetterBox(): Shape
}
DarkTheme --> Status

class SusTheme implements Theme {
    - backgroundColor: Color
    - textColor: Color
    - outlineColor: Color
    - letterFont: Font
    - titleFont: Font
    - buttonFont: Font
    - statusColors: Map<Status, Color>
    - letterBox: Shape
    + SusTheme()
    - {static} getPath(): Path2D
    + getBackgroundColor(): Color
    + getTextColor(): Color
    + getOutlineColor(): Color
    + getLetterFont(): Font
    + getTitleFont(): Font
    + getButtonFont(): Font
    + getColorForStatus(status: Status): Color
    + getLetterBox(): Shape
}
SusTheme --> Status


WordGenerator --> WordChecker

note "Can be extended to support\ndifferent languages or numbers" as N1
WordGenerator .. N1
WordChecker .. N1


@enduml